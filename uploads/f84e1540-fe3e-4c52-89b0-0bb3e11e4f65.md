data:/var/lib/mysql
    networks:
      - laravel

  redis:
    image: redis:alpine
    restart: always
    volumes:
      - redisdata:/data
    networks:
      - laravel

networks:
  laravel:
    driver: bridge

volumes:
  storage:
    driver: local
  dbdata:
    driver: local
  redisdata:
    driver: local
```

---

## Advanced Features

### Add Xdebug for Debugging

Add to your `Dockerfile` before the CMD line:

```dockerfile
# Install Xdebug
RUN pecl install xdebug \
    && docker-php-ext-enable xdebug

# Xdebug configuration
RUN echo "xdebug.mode=debug" >> /usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini \
    && echo "xdebug.start_with_request=yes" >> /usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini \
    && echo "xdebug.client_host=host.docker.internal" >> /usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini \
    && echo "xdebug.client_port=9003" >> /usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini \
    && echo "xdebug.log=/tmp/xdebug.log" >> /usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini
```

VSCode `launch.json` configuration:

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Listen for Xdebug",
            "type": "php",
            "request": "launch",
            "port": 9003,
            "pathMappings": {
                "/var/www": "${workspaceFolder}"
            }
        }
    ]
}
```

### Add PostgreSQL Instead of MySQL

Replace the db service in `docker-compose.yml`:

```yaml
  db:
    image: postgres:15-alpine
    container_name: laravel-postgres
    restart: unless-stopped
    environment:
      POSTGRES_DB: ${DB_DATABASE:-laravel}
      POSTGRES_USER: ${DB_USERNAME:-laravel}
      POSTGRES_PASSWORD: ${DB_PASSWORD:-secret}
    volumes:
      - pgdata:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    networks:
      - laravel

volumes:
  pgdata:
    driver: local
```

Update `.env`:

```env
DB_CONNECTION=pgsql
DB_HOST=db
DB_PORT=5432
DB_DATABASE=laravel
DB_USERNAME=laravel
DB_PASSWORD=secret
```

### Add Elasticsearch

Add to `docker-compose.yml`:

```yaml
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0
    container_name: laravel-elasticsearch
    restart: unless-stopped
    environment:
      - discovery.type=single-node
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
      - xpack.security.enabled=false
    volumes:
      - esdata:/usr/share/elasticsearch/data
    ports:
      - "9200:9200"
    networks:
      - laravel

volumes:
  esdata:
    driver: local
```

### Add Minio for S3-Compatible Storage

Add to `docker-compose.yml`:

```yaml
  minio:
    image: minio/minio
    container_name: laravel-minio
    restart: unless-stopped
    ports:
      - "9000:9000"
      - "9001:9001"
    environment:
      MINIO_ROOT_USER: minioadmin
      MINIO_ROOT_PASSWORD: minioadmin
    volumes:
      - minio_data:/data
    command: server /data --console-address ":9001"
    networks:
      - laravel

volumes:
  minio_data:
    driver: local
```

Update `.env`:

```env
FILESYSTEM_DISK=s3
AWS_ACCESS_KEY_ID=minioadmin
AWS_SECRET_ACCESS_KEY=minioadmin
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=laravel
AWS_ENDPOINT=http://minio:9000
AWS_USE_PATH_STYLE_ENDPOINT=true
```

---

## Monitoring and Performance

### Add Laravel Telescope

```bash
# Install Telescope
docker-compose exec app composer require laravel/telescope --dev

# Publish assets
docker-compose exec app php artisan telescope:install

# Run migrations
docker-compose exec app php artisan migrate

# Clear config
docker-compose exec app php artisan config:clear
```

Access Telescope at: http://localhost:8000/telescope

### Add Laravel Horizon (for queue monitoring)

```bash
# Install Horizon
docker-compose exec app composer require laravel/horizon

# Publish assets
docker-compose exec app php artisan horizon:install

# Update the queue service in docker-compose.yml to use Horizon
```

Update queue service command in `docker-compose.yml`:

```yaml
  queue:
    command: php artisan horizon
```

Access Horizon at: http://localhost:8000/horizon

### Performance Optimization Commands

```bash
# Cache everything for better performance
docker-compose exec app php artisan optimize

# This runs:
# - config:cache
# - route:cache
# - view:cache
# - event:cache

# Clear all caches
docker-compose exec app php artisan optimize:clear

# Enable OPcache (already in php.ini)
# Verify it's enabled
docker-compose exec app php -i | grep opcache
```

---

## CI/CD Integration

### GitHub Actions Workflow

Create `.github/workflows/laravel.yml`:

```yaml
name: Laravel Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  tests:
    runs-on: ubuntu-latest

    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: secret
          MYSQL_DATABASE: laravel_test
        ports:
          - 3306:3306
        options: --health-cmd="mysqladmin ping" --health-interval=10s --health-timeout=5s --health-retries=3

      redis:
        image: redis:alpine
        ports:
          - 6379:6379
        options: --health-cmd="redis-cli ping" --health-interval=10s --health-timeout=5s --health-retries=3

    steps:
    - uses: actions/checkout@v3

    - name: Setup PHP
      uses: shivammathur/setup-php@v2
      with:
        php-version: '8.2'
        extensions: mbstring, pdo, pdo_mysql, zip, gd
        coverage: none

    - name: Copy .env
      run: php -r "file_exists('.env') || copy('.env.example', '.env');"

    - name: Install Dependencies
      run: composer install -q --no-ansi --no-interaction --no-scripts --no-progress --prefer-dist

    - name: Generate key
      run: php artisan key:generate

    - name: Directory Permissions
      run: chmod -R 777 storage bootstrap/cache

    - name: Run Migrations
      env:
        DB_CONNECTION: mysql
        DB_HOST: 127.0.0.1
        DB_PORT: 3306
        DB_DATABASE: laravel_test
        DB_USERNAME: root
        DB_PASSWORD: secret
      run: php artisan migrate

    - name: Execute tests (Unit and Feature tests) via PHPUnit
      env:
        DB_CONNECTION: mysql
        DB_HOST: 127.0.0.1
        DB_PORT: 3306
        DB_DATABASE: laravel_test
        DB_USERNAME: root
        DB_PASSWORD: secret
      run: php artisan test
```

### GitLab CI/CD

Create `.gitlab-ci.yml`:

```yaml
image: docker:latest

services:
  - docker:dind

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""

stages:
  - build
  - test
  - deploy

build:
  stage: build
  script:
    - docker-compose build
  only:
    - main
    - develop

test:
  stage: test
  script:
    - docker-compose up -d
    - docker-compose exec -T app composer install
    - docker-compose exec -T app php artisan key:generate
    - docker-compose exec -T app php artisan migrate
    - docker-compose exec -T app php artisan test
    - docker-compose down
  only:
    - main
    - develop

deploy:
  stage: deploy
  script:
    - echo "Deploying to production..."
    # Add your deployment scripts here
  only:
    - main
  when: manual
```

---

## Security Best Practices

### Secure Environment Variables

Create `.env.production` for production:

```env
APP_ENV=production
APP_DEBUG=false
APP_URL=https://yourdomain.com

DB_CONNECTION=mysql
DB_HOST=db
DB_PORT=3306
DB_DATABASE=production_db
DB_USERNAME=secure_user
DB_PASSWORD=very_secure_password

REDIS_PASSWORD=redis_secure_password
```

### Security Headers in Nginx

Update `docker/nginx/conf.d/default.conf`:

```nginx
server {
    listen 80;
    server_name localhost;
    root /var/www/public;
    index index.php index.html;

    charset utf-8;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;
    add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # Hide Nginx version
    server_tokens off;

    # Deny access to hidden files
    location ~ /\. {
        deny all;
        access_log off;
        log_not_found off;
    }

    # Deny access to sensitive files
    location ~ /\.(?:svn|git|hg|bzr|env) {
        deny all;
    }

    location / {
        try_files $uri $uri/ /index.php?$query_string;
        gzip_static on;
    }

    location ~ \.php$ {
        try_files $uri =404;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass app:9000;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param PATH_INFO $fastcgi_path_info;
        fastcgi_buffering off;
        fastcgi_read_timeout 300;
    }
}
```

### Limit Container Resources

Update `docker-compose.yml` to add resource limits:

```yaml
  app:
    build:
      context: .
      dockerfile: Dockerfile
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 2G
        reservations:
          cpus: '1'
          memory: 1G
    # ... rest of config
```

---

## Useful Scripts Collection

### Create `scripts/` Directory

```bash
mkdir -p scripts
```

### Script 1: Fresh Install

Create `scripts/fresh-install.sh`:

```bash
#!/bin/bash

echo "ğŸ”„ Fresh Laravel installation starting..."

# Stop containers
docker-compose down -v

# Remove vendor and node_modules
rm -rf vendor node_modules

# Rebuild containers
docker-compose build --no-cache

# Start containers
docker-compose up -d

# Wait for MySQL to be ready
echo "â³ Waiting for MySQL..."
sleep 15

# Install dependencies
docker-compose exec -T app composer install

# Generate key
docker-compose exec -T app php artisan key:generate

# Run migrations
docker-compose exec -T app php artisan migrate:fresh --seed

# Install npm
docker-compose exec -T app npm install

# Build assets
docker-compose exec -T app npm run build

# Set permissions
docker-compose exec -T -u root app chmod -R 775 storage bootstrap/cache

echo "âœ… Fresh installation complete!"
```

### Script 2: Quick Deploy

Create `scripts/deploy.sh`:

```bash
#!/bin/bash

echo "ğŸš€ Deploying Laravel application..."

# Pull latest changes
git pull origin main

# Stop containers
docker-compose down

# Rebuild containers
docker-compose build

# Start containers
docker-compose up -d

# Install dependencies
docker-compose exec -T app composer install --no-dev --optimize-autoloader

# Run migrations
docker-compose exec -T app php artisan migrate --force

# Cache everything
docker-compose exec -T app php artisan config:cache
docker-compose exec -T app php artisan route:cache
docker-compose exec -T app php artisan view:cache

# Install and build assets
docker-compose exec -T app npm ci
docker-compose exec -T app npm run build

# Restart queue workers
docker-compose restart queue

echo "âœ… Deployment complete!"
```

### Script 3: Run Tests

Create `scripts/test.sh`:

```bash
#!/bin/bash

echo "ğŸ§ª Running Laravel tests..."

# Create test database
docker-compose exec -T db mysql -u root -psecret -e "CREATE DATABASE IF NOT EXISTS laravel_test;"

# Run tests
docker-compose exec -T app php artisan test --parallel

# Generate coverage report (if needed)
# docker-compose exec -T app php artisan test --coverage

echo "âœ… Tests complete!"
```

### Script 4: Database Seed

Create `scripts/seed.sh`:

```bash
#!/bin/bash

echo "ğŸŒ± Seeding database..."

docker-compose exec app php artisan migrate:fresh --seed

echo "âœ… Database seeded!"
```

### Script 5: Clear All Caches

Create `scripts/clear-cache.sh`:

```bash
#!/bin/bash

echo "ğŸ§¹ Clearing all caches..."

docker-compose exec app php artisan cache:clear
docker-compose exec app php artisan config:clear
docker-compose exec app php artisan route:clear
docker-compose exec app php artisan view:clear
docker-compose exec app php artisan clear-compiled

docker-compose exec app composer dump-autoload

echo "âœ… All caches cleared!"
```

### Script 6: Health Check

Create `scripts/health-check.sh`:

```bash
#!/bin/bash

echo "ğŸ¥ Running health checks..."

# Check if containers are running
if [ "$(docker-compose ps -q app)" ]; then
    echo "âœ… App container is running"
else
    echo "âŒ App container is not running"
fi

if [ "$(docker-compose ps -q nginx)" ]; then
    echo "âœ… Nginx container is running"
else
    echo "âŒ Nginx container is not running"
fi

if [ "$(docker-compose ps -q db)" ]; then
    echo "âœ… Database container is running"
else
    echo "âŒ Database container is not running"
fi

if [ "$(docker-compose ps -q redis)" ]; then
    echo "âœ… Redis container is running"
else
    echo "âŒ Redis container is not running"
fi

# Test database connection
echo ""
echo "Testing database connection..."
docker-compose exec -T app php artisan tinker --execute="DB::connection()->getPdo();" && echo "âœ… Database connected" || echo "âŒ Database connection failed"

# Test Redis connection
echo ""
echo "Testing Redis connection..."
docker-compose exec -T app php artisan tinker --execute="Redis::connection()->ping();" && echo "âœ… Redis connected" || echo "âŒ Redis connection failed"

# Check disk usage
echo ""
echo "Disk usage:"
docker-compose exec -T app df -h /var/www

echo ""
echo "âœ… Health check complete!"
```

Make all scripts executable:

```bash
chmod +x scripts/*.sh
```

---

## Makefile for Easy Commands

Create a `Makefile` in your project root:

```makefile
.PHONY: help

help: ## Show this help message
	@echo 'Usage: make [target]'
	@echo ''
	@echo 'Available targets:'
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "\033[36m%-20s\033[0m %s\n", $$1, $$2}' $(MAKEFILE_LIST)

install: ## Install Laravel and start containers
	@./scripts/fresh-install.sh

up: ## Start all containers
	docker-compose up -d

down: ## Stop all containers
	docker-compose down

restart: ## Restart all containers
	docker-compose restart

build: ## Rebuild containers
	docker-compose build

rebuild: ## Rebuild containers without cache
	docker-compose build --no-cache

logs: ## View logs
	docker-compose logs -f

shell: ## Access app container shell
	docker-compose exec app bash

root: ## Access app container as root
	docker-compose exec -u root app bash

artisan: ## Run artisan command (usage: make artisan CMD="migrate")
	docker-compose exec app php artisan $(CMD)

composer: ## Run composer command (usage: make composer CMD="require package")
	docker-compose exec app composer $(CMD)

npm: ## Run npm command (usage: make npm CMD="install")
	docker-compose exec app npm $(CMD)

test: ## Run tests
	docker-compose exec app php artisan test

migrate: ## Run migrations
	docker-compose exec app php artisan migrate

fresh: ## Fresh migration with seed
	docker-compose exec app php artisan migrate:fresh --seed

seed: ## Run seeders
	docker-compose exec app php artisan db:seed

tinker: ## Open Tinker
	docker-compose exec app php artisan tinker

cache-clear: ## Clear all caches
	@./scripts/clear-cache.sh

optimize: ## Optimize Laravel
	docker-compose exec app php artisan optimize

mysql: ## Access MySQL CLI
	docker-compose exec db mysql -u laravel -psecret laravel

redis-cli: ## Access Redis CLI
	docker-compose exec redis redis-cli

backup: ## Backup database
	@./scripts/backup-db.sh

health: ## Run health check
	@./scripts/health-check.sh

deploy: ## Deploy application
	@./scripts/deploy.sh

clean: ## Remove all containers, images, and volumes
	docker-compose down -v --rmi all
```

Now you can use simple make commands:

```bash
make help       # Show all available commands
make install    # Fresh install
make up         # Start containers
make down       # Stop containers
make shell      # Access shell
make test       # Run tests
make migrate    # Run migrations
make fresh      # Fresh database
make logs       # View logs
make artisan CMD="route:list"  # Run artisan commands
make composer CMD="require package"  # Run composer
```

---

## Development Workflow Example

### Daily Development Flow

```bash
# Morning - Start your day
make up                    # Start containers
make logs                  # Check if everything is running

# Create a new feature
make shell                 # Access container
php artisan make:model Post -mcr
php artisan make:request StorePostRequest
exit

# Edit your code with your favorite editor
# Files are synced automatically via volume mounts

# Run migrations
make migrate

# Test your changes
make test

# Check your routes
make artisan CMD="route:list"

# View in browser
# http://localhost:8000

# End of day
make down                  # Stop containers
```

### Working with Git

```bash
# Create feature branch
git checkout -b feature/new-feature

# Make your changes
# ... code ...

# Test
make test

# Commit
git add .
git commit -m "Add new feature"

# Push
git push origin feature/new-feature

# Create pull request on GitHub/GitLab
```

---

## Complete Project Structure

Your final project structure should look like this:

```
my-laravel-app/
â”œâ”€â”€ app/
â”œâ”€â”€ bootstrap/
â”œâ”€â”€ config/
â”œâ”€â”€ database/
â”œâ”€â”€ docker/
â”‚   â”œâ”€â”€ mysql/
â”‚   â”‚   â””â”€â”€ my.cnf
â”‚   â”œâ”€â”€ nginx/
â”‚   â”‚   â”œâ”€â”€ conf.d/
â”‚   â”‚   â”‚   â””â”€â”€ default.conf
â”‚   â”‚   â””â”€â”€ logs/
â”‚   â””â”€â”€ php/
â”‚       â””â”€â”€ php.ini
â”œâ”€â”€ public/
â”œâ”€â”€ resources/
â”œâ”€â”€ routes/
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ backup-db.sh
â”‚   â”œâ”€â”€ clear-cache.sh
â”‚   â”œâ”€â”€ deploy.sh
â”‚   â”œâ”€â”€ fresh-install.sh
â”‚   â”œâ”€â”€ health-check.sh
â”‚   â”œâ”€â”€ restore-db.sh
â”‚   â”œâ”€â”€ seed.sh
â”‚   â””â”€â”€ test.sh
â”œâ”€â”€ storage/
â”œâ”€â”€ tests/
â”œâ”€â”€ .env
â”œâ”€â”€ .env.example
â”œâ”€â”€ .gitignore
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ docker-compose.prod.yml
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ Dockerfile.prod
â”œâ”€â”€ docker-aliases.sh
â”œâ”€â”€ Makefile
â”œâ”€â”€ setup.sh
â”œâ”€â”€ artisan
â”œâ”€â”€ composer.json
â”œâ”€â”€ package.json
â””â”€â”€ README.md
```

---

## Final Tips and Best Practices

### 1. Environment-Specific Configurations

Always use different configurations for development and production:

- Development: Full logging, debug mode, local storage
- Production: Minimal logging, no debug, cloud storage

### 2. Version Control

Add to `.gitignore`:

```gitignore
/vendor/
/node_modules/
/public/hot
/public/storage
/storage/*.key
/. env
.env.backup
.phpunit.result.cache
docker-compose.override.yml
Homestead.json
Homestead.yaml
npm-debug.log
yarn-error.log
/.idea
/.vscode
```

### 3. Regular Maintenance

```bash
# Weekly tasks
make clean          # Clean old images
make backup         # Backup database
make test           # Run full test suite

# Monthly tasks
docker system prune -a  # Clean Docker system
```

### 4. Performance Tips

- Use volume mounts for development, but copy files for production
- Enable OPcache in production
- Use Redis for cache and sessions
- Compile assets before deployment
- Use CDN for static assets in production

### 5. Security Checklist

- [ ] Never commit `.env` file
- [ ] Use strong passwords for production
- [ ] Keep Docker images updated
- [ ] Limit container resources
- [ ] Enable HTTPS in production
- [ ] Use security headers
- [ ] Regular security audits with `composer audit`

---

## Troubleshooting Common Issues

### Issue 1: Port Already in Use

```bash
# Find what's using the port
sudo lsof -i :8000

# Kill the process
kill -9 <PID>

# Or change the port in docker-compose.yml
ports:
  - "8001:80"  # Changed from 8000 to 8001
```

### Issue 2: Permission Denied

```bash
# Fix permissions
make root
chown -R www-data:www-data /var/www/storage
chown -R www-data:www-data /var/www/bootstrap/cache
chmod -R 775 /var/www/storage
chmod -R 775 /var/www/bootstrap/cache
exit
```

### Issue 3: Database Connection Refused

```bash
# Check if database is running
docker-compose ps db

# Check database logs
docker-compose logs db

# Wait for database to be ready
sleep 10
docker-compose exec app php artisan migrate
```

### Issue 4: Composer Memory Limit

```bash
# Increase memory limit temporarily
docker-compose exec app php -d memory_limit=-1 /usr/bin/composer install
```

### Issue 5: npm ERR!

```bash
# Clear npm cache
docker-compose exec app npm cache clean --force

# Remove node_modules and reinstall
docker-compose exec app rm -rf node_modules package-lock.json
docker-compose exec app npm install
```

---

## Additional Resources

### Official Documentation
- Laravel: https://laravel.com/docs
- Docker: https://docs.docker.com
- Docker Compose: https://docs.docker.com/compose
- Nginx: https://nginx.org/en/docs

### Community Resources
- Laravel News: https://laravel-news.com
- Laracasts: https://laracasts.com
- Laravel Daily: https://laraveldaily.com

### Useful Packages
```bash
# Development
docker-compose exec app composer require --dev barryvdh/laravel-debugbar
docker-compose exec app composer require --dev barryvdh/laravel-ide-helper

# Production
docker-compose exec app composer require predis/predis
docker-compose exec app composer require laravel/horizon
docker-compose exec app composer require laravel/telescope --dev
```

---

## Conclusion

You now have a complete, production-ready Laravel development environment running entirely in Docker! This setup provides:

âœ… Zero local dependencies (just Docker)
âœ… Consistent environment across all developers
âœ… Easy onboarding for new team members
âœ… Isolated projects with different PHP versions
âœ… Production-like development environment
âœ… Comprehensive tooling and scripts
âœ… Easy deployment workflow

Remember to:
- Keep your Docker images updated
- Regularly backup your database
- Run tests before deploying
- Monitor your application performance
- Follow Laravel and Docker best practices

Happy coding! ğŸš€