# Laravel Sail Production Deployment Guide

**Date Created:** December 24, 2025
**Purpose:** Complete guide for deploying Laravel Sail applications to production using Docker containers, with manual and automated Jenkins deployment methods.

---

## Table of Contents

1. [Overview](#overview)
2. [Prerequisites](#prerequisites)
3. [Production Docker Setup](#production-docker-setup)
4. [Manual Deployment from GitHub](#manual-deployment-from-github)
5. [Automated Jenkins Deployment](#automated-jenkins-deployment)
6. [Monitoring and Maintenance](#monitoring-and-maintenance)
7. [Troubleshooting](#troubleshooting)

---

## Overview

This guide covers:
- Converting Laravel Sail development environment to production
- Manual deployment process from GitHub
- Automated CI/CD pipeline using Jenkins
- Docker container orchestration for production
- Security best practices

---

## Prerequisites

### Required Software
- Docker Engine (20.10+)
- Docker Compose (2.0+)
- Git
- A server with at least 2GB RAM
- Domain name (optional but recommended)

### Access Requirements
- SSH access to production server
- GitHub repository access
- Jenkins server (for automated deployment)

---

## Production Docker Setup

### Step 1: Create Production Docker Configuration

#### 1.1 Create Production Dockerfile

Create a file named `Dockerfile.production` in your project root:

```dockerfile
FROM php:8.2-fpm

# Set working directory
WORKDIR /var/www/html

# Install system dependencies
RUN apt-get update && apt-get install -y \
    git \
    curl \
    libpng-dev \
    libonig-dev \
    libxml2-dev \
    libzip-dev \
    zip \
    unzip \
    nginx \
    supervisor \
    && docker-php-ext-install pdo_mysql mbstring exif pcntl bcmath gd zip

# Install Composer
COPY --from=composer:latest /usr/bin/composer /usr/bin/composer

# Copy application files
COPY . /var/www/html

# Install PHP dependencies
RUN composer install --no-dev --optimize-autoloader --no-interaction

# Set permissions
RUN chown -R www-data:www-data /var/www/html \
    && chmod -R 755 /var/www/html/storage \
    && chmod -R 755 /var/www/html/bootstrap/cache

# Copy nginx configuration
COPY docker/nginx/nginx.conf /etc/nginx/nginx.conf
COPY docker/nginx/default.conf /etc/nginx/sites-available/default

# Copy supervisor configuration
COPY docker/supervisor/supervisord.conf /etc/supervisor/conf.d/supervisord.conf

# Expose port
EXPOSE 80

# Start supervisor
CMD ["/usr/bin/supervisord", "-c", "/etc/supervisor/conf.d/supervisord.conf"]
```

#### 1.2 Create Nginx Configuration

Create directory structure:
```bash
mkdir -p docker/nginx
```

Create `docker/nginx/nginx.conf`:

```nginx
user www-data;
worker_processes auto;
pid /run/nginx.pid;

events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    gzip on;
    gzip_disable "msie6";
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml text/javascript application/json application/javascript application/xml+rss application/rss+xml font/truetype font/opentype application/vnd.ms-fontobject image/svg+xml;

    include /etc/nginx/sites-available/*;
}
```

Create `docker/nginx/default.conf`:

```nginx
server {
    listen 80;
    server_name _;
    root /var/www/html/public;

    add_header X-Frame-Options "SAMEORIGIN";
    add_header X-Content-Type-Options "nosniff";

    index index.php;

    charset utf-8;

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location = /favicon.ico { access_log off; log_not_found off; }
    location = /robots.txt  { access_log off; log_not_found off; }

    error_page 404 /index.php;

    location ~ \.php$ {
        fastcgi_pass 127.0.0.1:9000;
        fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;
        include fastcgi_params;
    }

    location ~ /\.(?!well-known).* {
        deny all;
    }
}
```

#### 1.3 Create Supervisor Configuration

Create directory:
```bash
mkdir -p docker/supervisor
```

Create `docker/supervisor/supervisord.conf`:

```ini
[supervisord]
nodaemon=true
user=root
logfile=/var/log/supervisor/supervisord.log
pidfile=/var/run/supervisord.pid

[program:php-fpm]
command=/usr/local/sbin/php-fpm -F
stdout_logfile=/dev/stdout
stdout_logfile_maxbytes=0
stderr_logfile=/dev/stderr
stderr_logfile_maxbytes=0
autorestart=true
startretries=3

[program:nginx]
command=/usr/sbin/nginx -g 'daemon off;'
stdout_logfile=/dev/stdout
stdout_logfile_maxbytes=0
stderr_logfile=/dev/stderr
stderr_logfile_maxbytes=0
autorestart=true
startretries=3

[program:laravel-worker]
process_name=%(program_name)s_%(process_num)02d
command=php /var/www/html/artisan queue:work --sleep=3 --tries=3 --max-time=3600
autostart=true
autorestart=true
stopasgroup=true
killasgroup=true
user=www-data
numprocs=2
redirect_stderr=true
stdout_logfile=/var/www/html/storage/logs/worker.log
stopwaitsecs=3600

[program:laravel-scheduler]
command=/bin/bash -c "while [ true ]; do (php /var/www/html/artisan schedule:run --verbose --no-interaction &); sleep 60; done"
autostart=true
autorestart=true
user=www-data
stdout_logfile=/var/www/html/storage/logs/scheduler.log
```

#### 1.4 Create Production Docker Compose File

Create `docker-compose.production.yml`:

```yaml
version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile.production
    container_name: laravel-app
    restart: unless-stopped
    ports:
      - "80:80"
    environment:
      - APP_ENV=production
      - APP_DEBUG=false
    env_file:
      - .env.production
    volumes:
      - ./storage:/var/www/html/storage
      - ./bootstrap/cache:/var/www/html/bootstrap/cache
    networks:
      - laravel-network
    depends_on:
      - mysql
      - redis

  mysql:
    image: mysql:8.0
    container_name: laravel-mysql
    restart: unless-stopped
    ports:
      - "3306:3306"
    environment:
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_USER: ${DB_USERNAME}
      MYSQL_PASSWORD: ${DB_PASSWORD}
    volumes:
      - mysql-data:/var/lib/mysql
    networks:
      - laravel-network
    command: --default-authentication-plugin=mysql_native_password

  redis:
    image: redis:alpine
    container_name: laravel-redis
    restart: unless-stopped
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    networks:
      - laravel-network

networks:
  laravel-network:
    driver: bridge

volumes:
  mysql-data:
    driver: local
  redis-data:
    driver: local
```

#### 1.5 Create Production Environment File Template

Create `.env.production.example`:

```bash
APP_NAME=Laravel
APP_ENV=production
APP_KEY=
APP_DEBUG=false
APP_URL=http://your-domain.com

LOG_CHANNEL=stack
LOG_DEPRECATIONS_CHANNEL=null
LOG_LEVEL=error

DB_CONNECTION=mysql
DB_HOST=mysql
DB_PORT=3306
DB_DATABASE=laravel
DB_USERNAME=laravel
DB_PASSWORD=your-secure-password

BROADCAST_DRIVER=log
CACHE_DRIVER=redis
FILESYSTEM_DISK=local
QUEUE_CONNECTION=redis
SESSION_DRIVER=redis
SESSION_LIFETIME=120

REDIS_HOST=redis
REDIS_PASSWORD=null
REDIS_PORT=6379

MAIL_MAILER=smtp
MAIL_HOST=mailhog
MAIL_PORT=1025
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null
MAIL_FROM_ADDRESS="hello@example.com"
MAIL_FROM_NAME="${APP_NAME}"
```

---

## Manual Deployment from GitHub

### Step 2: Prepare Your Server

#### 2.1 Connect to Your Server

```bash
ssh user@your-server-ip
```

#### 2.2 Install Required Software

```bash
# Update system
sudo apt update && sudo apt upgrade -y

# Install Docker
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh

# Add your user to docker group
sudo usermod -aG docker $USER

# Install Docker Compose
sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose

# Verify installations
docker --version
docker-compose --version

# Log out and back in for group changes to take effect
exit
```

### Step 3: Clone and Configure Application

#### 3.1 Clone Repository

```bash
# Create application directory
sudo mkdir -p /var/www
cd /var/www

# Clone your repository
sudo git clone https://github.com/your-username/your-repo.git laravel-app
cd laravel-app

# Set ownership
sudo chown -R $USER:$USER /var/www/laravel-app
```

#### 3.2 Configure Environment

```bash
# Copy environment file
cp .env.production.example .env.production

# Edit environment variables
nano .env.production
```

Update the following in `.env.production`:
- `APP_KEY` (generate with: `php artisan key:generate --show`)
- `APP_URL`
- `DB_PASSWORD`
- Other production-specific settings

#### 3.3 Generate Application Key

```bash
# Generate app key
docker run --rm -v $(pwd):/app composer:latest sh -c "cd /app && php artisan key:generate"

# Or if you have PHP locally
php artisan key:generate
```

Add the generated key to your `.env.production` file.

### Step 4: Build and Deploy

#### 4.1 Build Docker Image

```bash
# Build the production image
docker build -f Dockerfile.production -t laravel-app:latest .
```

#### 4.2 Start Services

```bash
# Start all services
docker-compose -f docker-compose.production.yml up -d

# Check running containers
docker ps
```

#### 4.3 Run Laravel Setup Commands

```bash
# Run migrations
docker exec laravel-app php artisan migrate --force

# Clear and cache configuration
docker exec laravel-app php artisan config:cache
docker exec laravel-app php artisan route:cache
docker exec laravel-app php artisan view:cache

# Create storage link
docker exec laravel-app php artisan storage:link

# Set proper permissions
docker exec laravel-app chown -R www-data:www-data /var/www/html/storage
docker exec laravel-app chown -R www-data:www-data /var/www/html/bootstrap/cache
```

#### 4.4 Verify Deployment

```bash
# Check logs
docker-compose -f docker-compose.production.yml logs -f app

# Test application
curl http://localhost

# Or visit your server IP in browser
```

### Step 5: Create Deployment Script

Create `deploy.sh` in your project root:

```bash
#!/bin/bash

# Laravel Production Deployment Script
# Usage: ./deploy.sh

set -e

echo "üöÄ Starting deployment..."

# Configuration
APP_DIR="/var/www/laravel-app"
BRANCH="main"

# Navigate to application directory
cd $APP_DIR

# Pull latest changes
echo "üì¶ Pulling latest changes from GitHub..."
git pull origin $BRANCH

# Stop running containers
echo "üõë Stopping containers..."
docker-compose -f docker-compose.production.yml down

# Rebuild image
echo "üî® Building Docker image..."
docker build -f Dockerfile.production -t laravel-app:latest .

# Start containers
echo "‚ñ∂Ô∏è  Starting containers..."
docker-compose -f docker-compose.production.yml up -d

# Wait for services to be ready
echo "‚è≥ Waiting for services..."
sleep 10

# Run Laravel commands
echo "üîß Running Laravel commands..."
docker exec laravel-app php artisan migrate --force
docker exec laravel-app php artisan config:cache
docker exec laravel-app php artisan route:cache
docker exec laravel-app php artisan view:cache

# Set permissions
echo "üîê Setting permissions..."
docker exec laravel-app chown -R www-data:www-data /var/www/html/storage
docker exec laravel-app chown -R www-data:www-data /var/www/html/bootstrap/cache

# Clean up old images
echo "üßπ Cleaning up..."
docker image prune -f

echo "‚úÖ Deployment completed successfully!"

# Show running containers
docker ps

# Show recent logs
echo ""
echo "üìã Recent logs:"
docker-compose -f docker-compose.production.yml logs --tail=50 app
```

Make it executable:

```bash
chmod +x deploy.sh
```

#### 5.1 Deploy Using Script

```bash
# Run deployment
./deploy.sh
```

---

## Automated Jenkins Deployment

### Step 6: Jenkins Server Setup

#### 6.1 Install Jenkins

On your Jenkins server:

```bash
# Install Java
sudo apt update
sudo apt install openjdk-11-jdk -y

# Add Jenkins repository
curl -fsSL https://pkg.jenkins.io/debian-stable/jenkins.io-2023.key | sudo tee \
  /usr/share/keyrings/jenkins-keyring.asc > /dev/null

echo deb [signed-by=/usr/share/keyrings/jenkins-keyring.asc] \
  https://pkg.jenkins.io/debian-stable binary/ | sudo tee \
  /etc/apt/sources.list.d/jenkins.list > /dev/null

# Install Jenkins
sudo apt update
sudo apt install jenkins -y

# Start Jenkins
sudo systemctl start jenkins
sudo systemctl enable jenkins

# Get initial admin password
sudo cat /var/lib/jenkins/secrets/initialAdminPassword
```

Access Jenkins at `http://your-jenkins-server:8080`

#### 6.2 Install Required Jenkins Plugins

Navigate to: **Manage Jenkins** ‚Üí **Manage Plugins** ‚Üí **Available**

Install these plugins:
- Git Plugin
- GitHub Plugin
- Docker Plugin
- Docker Pipeline
- Pipeline
- Credentials Binding Plugin
- SSH Agent Plugin

#### 6.3 Configure Jenkins Credentials

**Manage Jenkins** ‚Üí **Manage Credentials** ‚Üí **System** ‚Üí **Global credentials**

Add the following credentials:

1. **GitHub Credentials**
   - Kind: Username with password
   - Username: Your GitHub username
   - Password: Personal Access Token
   - ID: `github-credentials`

2. **Production Server SSH Key**
   - Kind: SSH Username with private key
   - ID: `production-server-ssh`
   - Username: Your server username
   - Private Key: Paste your SSH private key

3. **Docker Hub Credentials** (optional)
   - Kind: Username with password
   - ID: `dockerhub-credentials`

### Step 7: Configure GitHub Webhook

#### 7.1 In GitHub Repository

1. Go to your repository settings
2. Click **Webhooks** ‚Üí **Add webhook**
3. Payload URL: `http://your-jenkins-server:8080/github-webhook/`
4. Content type: `application/json`
5. Events: Select "Just the push event"
6. Active: ‚úì checked
7. Click **Add webhook**

#### 7.2 Configure Jenkins GitHub Integration

**Manage Jenkins** ‚Üí **Configure System** ‚Üí **GitHub**

- Add GitHub Server
- API URL: `https://api.github.com`
- Credentials: Select your GitHub credentials
- Test connection

### Step 8: Create Jenkins Pipeline

#### 8.1 Create New Pipeline Job

1. Click **New Item**
2. Enter name: `laravel-production-deployment`
3. Select **Pipeline**
4. Click **OK**

#### 8.2 Configure Pipeline

**General:**
- ‚úì GitHub project
- Project url: `https://github.com/your-username/your-repo/`

**Build Triggers:**
- ‚úì GitHub hook trigger for GITScm polling

**Pipeline:**
- Definition: Pipeline script from SCM
- SCM: Git
- Repository URL: `https://github.com/your-username/your-repo.git`
- Credentials: Select github-credentials
- Branch: `*/main`
- Script Path: `Jenkinsfile`

### Step 9: Create Jenkinsfile

Create `Jenkinsfile` in your project root:

```groovy
pipeline {
    agent any
    
    environment {
        APP_NAME = 'laravel-app'
        DOCKER_IMAGE = 'laravel-app:latest'
        PRODUCTION_SERVER = 'user@your-server-ip'
        APP_DIR = '/var/www/laravel-app'
    }
    
    stages {
        stage('Checkout') {
            steps {
                echo 'üì¶ Checking out code...'
                checkout scm
            }
        }
        
        stage('Environment Check') {
            steps {
                echo 'üîç Checking environment...'
                sh '''
                    echo "Node: $(node --version)" || echo "Node not installed"
                    echo "Docker: $(docker --version)"
                    echo "Docker Compose: $(docker-compose --version)"
                '''
            }
        }
        
        stage('Install Dependencies') {
            steps {
                echo 'üìö Installing dependencies...'
                sh '''
                    docker run --rm -v $(pwd):/app composer:latest install --no-dev --optimize-autoloader --no-interaction
                '''
            }
        }
        
        stage('Run Tests') {
            steps {
                echo 'üß™ Running tests...'
                sh '''
                    docker run --rm -v $(pwd):/app -w /app php:8.2-cli php artisan test || echo "Tests skipped"
                '''
            }
        }
        
        stage('Build Docker Image') {
            steps {
                echo 'üî® Building Docker image...'
                sh '''
                    docker build -f Dockerfile.production -t ${DOCKER_IMAGE} .
                '''
            }
        }
        
        stage('Deploy to Production') {
            steps {
                echo 'üöÄ Deploying to production server...'
                sshagent(['production-server-ssh']) {
                    sh '''
                        # Copy necessary files
                        scp -o StrictHostKeyChecking=no docker-compose.production.yml ${PRODUCTION_SERVER}:${APP_DIR}/
                        scp -o StrictHostKeyChecking=no .env.production ${PRODUCTION_SERVER}:${APP_DIR}/.env.production
                        
                        # Execute deployment on production server
                        ssh -o StrictHostKeyChecking=no ${PRODUCTION_SERVER} << 'ENDSSH'
                            cd ${APP_DIR}
                            
                            # Pull latest code
                            git pull origin main
                            
                            # Stop containers
                            docker-compose -f docker-compose.production.yml down
                            
                            # Build image on production server
                            docker build -f Dockerfile.production -t ${DOCKER_IMAGE} .
                            
                            # Start containers
                            docker-compose -f docker-compose.production.yml up -d
                            
                            # Wait for services
                            sleep 15
                            
                            # Run migrations
                            docker exec laravel-app php artisan migrate --force
                            
                            # Cache optimization
                            docker exec laravel-app php artisan config:cache
                            docker exec laravel-app php artisan route:cache
                            docker exec laravel-app php artisan view:cache
                            
                            # Set permissions
                            docker exec laravel-app chown -R www-data:www-data /var/www/html/storage
                            docker exec laravel-app chown -R www-data:www-data /var/www/html/bootstrap/cache
                            
                            # Clean up
                            docker image prune -f
ENDSSH
                    '''
                }
            }
        }
        
        stage('Verify Deployment') {
            steps {
                echo '‚úÖ Verifying deployment...'
                sshagent(['production-server-ssh']) {
                    sh '''
                        ssh -o StrictHostKeyChecking=no ${PRODUCTION_SERVER} << 'ENDSSH'
                            docker ps
                            curl -I http://localhost || echo "Health check failed"
ENDSSH
                    '''
                }
            }
        }
    }
    
    post {
        success {
            echo '‚úÖ Deployment completed successfully!'
        }
        failure {
            echo '‚ùå Deployment failed!'
        }
        always {
            echo 'üßπ Cleaning up workspace...'
            cleanWs()
        }
    }
}
```

#### 9.1 Advanced Jenkinsfile with Rollback

Create `Jenkinsfile.advanced` for production with rollback capability:

```groovy
pipeline {
    agent any
    
    environment {
        APP_NAME = 'laravel-app'
        DOCKER_IMAGE = "laravel-app:${env.BUILD_NUMBER}"
        DOCKER_IMAGE_LATEST = 'laravel-app:latest'
        PRODUCTION_SERVER = 'user@your-server-ip'
        APP_DIR = '/var/www/laravel-app'
        SLACK_CHANNEL = '#deployments' // Optional
    }
    
    parameters {
        choice(name: 'DEPLOY_ENV', choices: ['production', 'staging'], description: 'Deployment environment')
        booleanParam(name: 'RUN_TESTS', defaultValue: true, description: 'Run tests before deployment')
        booleanParam(name: 'SKIP_BACKUP', defaultValue: false, description: 'Skip database backup')
    }
    
    stages {
        stage('Checkout') {
            steps {
                echo 'üì¶ Checking out code...'
                checkout scm
                script {
                    env.GIT_COMMIT_MSG = sh(script: 'git log -1 --pretty=%B', returnStdout: true).trim()
                    env.GIT_AUTHOR = sh(script: 'git log -1 --pretty=%an', returnStdout: true).trim()
                }
            }
        }
        
        stage('Install Dependencies') {
            steps {
                echo 'üìö Installing dependencies...'
                sh '''
                    docker run --rm -v $(pwd):/app composer:latest install --no-dev --optimize-autoloader --no-interaction
                '''
            }
        }
        
        stage('Run Tests') {
            when {
                expression { params.RUN_TESTS == true }
            }
            steps {
                echo 'üß™ Running tests...'
                sh '''
                    docker run --rm \
                        -v $(pwd):/app \
                        -w /app \
                        php:8.2-cli \
                        sh -c "php artisan test --parallel"
                '''
            }
        }
        
        stage('Security Scan') {
            steps {
                echo 'üîí Running security scan...'
                sh '''
                    docker run --rm -v $(pwd):/app composer:latest audit || echo "Security scan completed with warnings"
                '''
            }
        }
        
        stage('Build Docker Image') {
            steps {
                echo 'üî® Building Docker image...'
                sh '''
                    docker build \
                        -f Dockerfile.production \
                        -t ${DOCKER_IMAGE} \
                        -t ${DOCKER_IMAGE_LATEST} \
                        --build-arg BUILD_NUMBER=${BUILD_NUMBER} \
                        --build-arg GIT_COMMIT=${GIT_COMMIT} \
                        .
                '''
            }
        }
        
        stage('Backup Database') {
            when {
                expression { params.SKIP_BACKUP == false }
            }
            steps {
                echo 'üíæ Creating database backup...'
                sshagent(['production-server-ssh']) {
                    sh '''
                        ssh -o StrictHostKeyChecking=no ${PRODUCTION_SERVER} << 'ENDSSH'
                            mkdir -p ${APP_DIR}/backups
                            BACKUP_FILE="${APP_DIR}/backups/db-backup-$(date +%Y%m%d-%H%M%S).sql"
                            docker exec laravel-mysql mysqldump -u root -p${DB_PASSWORD} ${DB_DATABASE} > $BACKUP_FILE
                            echo "Backup created: $BACKUP_FILE"
                            
                            # Keep only last 5 backups
                            cd ${APP_DIR}/backups
                            ls -t db-backup-*.sql | tail -n +6 | xargs rm -f
ENDSSH
                    '''
                }
            }
        }
        
        stage('Deploy to Production') {
            steps {
                echo 'üöÄ Deploying to production server...'
                script {
                    sshagent(['production-server-ssh']) {
                        sh '''
                            # Transfer Docker image
                            docker save ${DOCKER_IMAGE} | ssh -o StrictHostKeyChecking=no ${PRODUCTION_SERVER} "docker load"
                            
                            # Copy necessary files
                            scp -o StrictHostKeyChecking=no docker-compose.production.yml ${PRODUCTION_SERVER}:${APP_DIR}/
                            
                            # Execute deployment
                            ssh -o StrictHostKeyChecking=no ${PRODUCTION_SERVER} << ENDSSH
                                cd ${APP_DIR}
                                
                                # Pull latest code
                                git pull origin main
                                
                                # Tag current running container for potential rollback
                                docker tag laravel-app:latest laravel-app:rollback || true
                                
                                # Update to new image
                                docker tag ${DOCKER_IMAGE} laravel-app:latest
                                
                                # Deploy with zero-downtime
                                docker-compose -f docker-compose.production.yml up -d --no-deps --build app
                                
                                # Wait for application to be ready
                                sleep 20
                                
                                # Health check
                                if ! curl -f http://localhost/api/health; then
                                    echo "Health check failed!"
                                    exit 1
                                fi
                                
                                # Run migrations
                                docker exec laravel-app php artisan migrate --force
                                
                                # Optimize
                                docker exec laravel-app php artisan optimize
                                
                                # Restart queue workers
                                docker exec laravel-app php artisan queue:restart
                                
                                # Clean up old containers
                                docker-compose -f docker-compose.production.yml down --remove-orphans
                                docker-compose -f docker-compose.production.yml up -d
                                
                                # Cleanup
                                docker image prune -f
ENDSSH
                        '''
                    }
                }
            }
        }
        
        stage('Smoke Tests') {
            steps {
                echo 'üî• Running smoke tests...'
                sshagent(['production-server-ssh']) {
                    sh '''
                        ssh -o StrictHostKeyChecking=no ${PRODUCTION_SERVER} << 'ENDSSH'
                            # Test homepage
                            curl -f http://localhost/ || exit 1
                            
                            # Test API endpoint
                            curl -f http://localhost/api/health || exit 1
                            
                            # Check logs for errors
                            docker logs laravel-app --tail=50 | grep -i error && exit 1 || true
                            
                            echo "Smoke tests passed!"
ENDSSH
                    '''
                }
            }
        }
    }
    
    post {
        success {
            echo '‚úÖ Deployment completed successfully!'
            // Optional: Send Slack notification
            // slackSend(channel: env.SLACK_CHANNEL, color: 'good', message: "Deployment successful: ${env.JOB_NAME} #${env.BUILD_NUMBER}")
        }
        failure {
            echo '‚ùå Deployment failed! Initiating rollback...'
            script {
                sshagent(['production-server-ssh']) {
                    sh '''
                        ssh -o StrictHostKeyChecking=no ${PRODUCTION_SERVER} << 'ENDSSH'
                            cd ${APP_DIR}
                            
                            # Rollback to previous image
                            docker tag laravel-app:rollback laravel-app:latest
                            docker-compose -f docker-compose.production.yml up -d --force-recreate app
                            
                            echo "Rollback completed!"
ENDSSH
                    '''
                }
            }
            // Optional: Send Slack notification
            // slackSend(channel: env.SLACK_CHANNEL, color: 'danger', message: "Deployment failed and rolled back: ${env.JOB_NAME} #${env.BUILD_NUMBER}")
        }
        always {
            echo 'üßπ Cleaning up workspace...'
            cleanWs()
        }
    }
}
```

### Step 10: Setup SSH Access for Jenkins

On Jenkins server:

```bash
# Switch to Jenkins user
sudo su - jenkins

# Generate SSH key
ssh-keygen -t rsa -b 4096 -C "jenkins@your-jenkins-server"

# Copy public key
cat ~/.ssh/id_rsa.pub
```

On production server:

```bash
# Add Jenkins public key to authorized_keys
echo "jenkins-public-key-here" >> ~/.ssh/authorized_keys

# Set proper permissions
chmod 600 ~/.ssh/authorized_keys
```

Test connection from Jenkins server:

```bash
ssh user@production-server
```

---

## Monitoring and Maintenance

### Step 11: Logging and Monitoring

#### 11.1 View Container Logs

```bash
# View all logs
docker-compose -f docker-compose.production.yml logs -f

# View specific service logs
docker-compose -f docker-compose.production.yml logs -f app

# View last N lines
docker-compose -f docker-compose.production.yml logs --tail=100 app
```

#### 11.2 Monitor Container Health

Create `monitor.sh`:

```bash
#!/bin/bash

# Monitor Laravel Docker containers

echo "=== Container Status ==="
docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

echo ""
echo "=== Resource Usage ==="
docker stats --no-stream

echo ""
echo "=== Disk Usage ==="
docker system df

echo ""
echo "=== Application Logs (last 20 lines) ==="
docker logs laravel-app --tail=20

echo ""
echo "=== Queue Status ==="
docker exec laravel-app php artisan queue:work --once --quiet && echo "Queue OK" || echo "Queue ERROR"
```

Make executable:
```bash
chmod +x monitor.sh
```

#### 11.3 Setup Log Rotation

Create `/etc/logrotate.d/laravel-docker`:

```
/var/lib/docker/containers/*/*.log {
  rotate 7
  daily
  compress
  size=50M
  missingok
  delaycompress
  copytruncate
}
```

### Step 12: Backup Strategy

Create `backup.sh`:

```bash
#!/bin/bash

# Laravel Production Backup Script

BACKUP_DIR="/var/backups/laravel"
DATE=$(date +%Y%m%d-%H%M%S)
APP_DIR="/var/www/laravel-app"

# Create backup directory
mkdir -p $BACKUP_DIR

# Backup database
echo "Backing up database..."
docker exec laravel-mysql mysqldump -u root -p${DB_PASSWORD} ${DB_DATABASE} | gzip > $BACKUP_DIR/db-$DATE.sql.gz

# Backup storage files
echo "Backing up storage..."
tar -czf $BACKUP_DIR/storage-$DATE.tar.gz -C $APP_DIR storage/app

# Backup environment file
echo "Backing up environment..."
cp $APP_DIR/.env.production $BACKUP_DIR/env-$DATE

# Keep only last 30 days of backups
find $BACKUP_DIR -type f -mtime +30 -delete

echo "Backup completed: $DATE"
```

#### 12.1 Setup Automated Backups with Cron

```bash
# Edit crontab
crontab -e

# Add daily backup at 2 AM
0 2 * * * /var/www/laravel-app/backup.sh >> /var/log/laravel-backup.log 2>&1
```

### Step 13: Maintenance Commands

#### 13.1 Update Application

```bash
# Run deployment script
./deploy.sh

# Or manually:
docker-compose -f docker-compose.production.yml down
git pull origin main
docker build -f Dockerfile.production -t laravel-app:latest .
docker-compose -f docker-compose.production.yml up -d
```

#### 13.2 Clear Application Cache

```bash
docker exec laravel-app php artisan cache:clear
docker exec laravel-app php artisan config:clear
docker exec laravel-app php artisan route:clear
docker exec laravel-app php artisan view:clear
```

#### 13.3 Run Artisan Commands

```bash
# General format
docker exec laravel-app php artisan [command]

# Examples:
docker exec laravel-app php artisan migrate:status
docker exec laravel-app php artisan queue:work
docker exec laravel-app php artisan schedule:run
```

#### 13.4 Database Operations

```bash
# Access MySQL CLI
docker exec -it laravel-mysql mysql -u root -p

# Run migrations
docker exec laravel-app php artisan migrate

# Rollback migrations
docker exec laravel-app php artisan migrate:rollback

# Fresh migration (destructive!)
docker exec laravel-app php artisan migrate:fresh --seed
```

---

## Troubleshooting

### Common Issues and Solutions

#### Issue 1: Container Won't Start

```bash
# Check logs
docker-compose -f docker-compose.production.yml logs app

# Check container status
docker ps -a

# Restart containers
docker-compose -f docker-compose.production.yml restart

# Nuclear option - rebuild everything
docker-compose -f docker-compose.production.yml down -v
docker system prune -a
docker-compose -f docker-compose.production.yml up -d --build
```

#### Issue 2: Permission Errors

```bash
# Fix storage permissions
docker exec laravel-app chown -R www-data:www-data /var/www/html/storage
docker exec laravel-app chmod -R 775 /var/www/html/storage

# Fix bootstrap cache permissions
docker exec laravel-app chown -R www-data:www-data /var/www/html/bootstrap/cache
docker exec laravel-app chmod -R 775 /var/www/html/bootstrap/cache
```

#### Issue 3: Database Connection Failed

```bash
# Check MySQL container
docker-compose -f docker-compose.production.yml ps mysql

# Check database logs
docker-compose -f docker-compose.production.yml logs mysql

# Test database connection
docker exec laravel-app php artisan migrate:status

# Restart database
docker-compose -f docker-compose.production.yml restart mysql
```

#### Issue 4: Queue Not Processing

```bash
# Check queue worker logs
docker exec laravel-app tail -f storage/logs/worker.log

# Restart queue workers
docker exec laravel-app php artisan queue:restart

# Manually process jobs
docker exec laravel-app php artisan queue:work --once

# Check failed jobs
docker exec laravel-app php artisan queue:failed
```

#### Issue 5: High Memory Usage

```bash
# Check resource usage
docker stats

# Restart specific container
docker-compose -f docker-compose.production.yml restart app

# Optimize application
docker exec laravel-app php artisan optimize:clear
docker exec laravel-app php artisan optimize
```

#### Issue 6: Jenkins Build Fails

```bash
# Check Jenkins logs
sudo tail -f /var/log/jenkins/jenkins.log

# Verify SSH connection
ssh -T user@production-server

# Check Jenkins credentials
# Go to Jenkins ‚Üí Credentials ‚Üí Test connection

# Rebuild without cache
# In Jenkins job, check "Clean before checkout"
```

### Debug Mode

To enable debug mode temporarily:

```bash
# Edit environment
docker exec laravel-app sed -i 's/APP_DEBUG=false/APP_DEBUG=true/' /var/www/html/.env.production

# Clear config cache
docker exec laravel-app php artisan config:clear

# Remember to disable after debugging!
docker exec laravel-app sed -i 's/APP_DEBUG=true/APP_DEBUG=false/' /var/www/html/.env.production
docker exec laravel-app php artisan config:cache
```

---

## Security Best Practices

### 1. Environment Variables

- Never commit `.env.production` to Git
- Use strong, unique passwords
- Rotate credentials regularly
- Use encrypted secrets in Jenkins

### 2. Docker Security

```bash
# Run security scan on image
docker scan laravel-app:latest

# Remove unused images
docker image prune -a

# Limit container resources in docker-compose.yml
services:
  app:
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 2G
```

### 3. Firewall Configuration

```bash
# Allow only necessary ports
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp
sudo ufw allow 22/tcp
sudo ufw enable

# Block direct database access from outside
sudo ufw deny 3306/tcp
```

### 4. SSL/TLS Setup (Recommended)

Use a reverse proxy like Nginx with Let's Encrypt:

```bash
# Install Certbot
sudo apt install certbot python3-certbot-nginx

# Get certificate
sudo certbot --nginx -d your-domain.com

# Auto-renewal
sudo certbot renew --dry-run
```

---

## Performance Optimization

### 1. Enable OPcache

Add to `Dockerfile.production`:

```dockerfile
RUN docker-php-ext-install opcache
COPY docker/php/opcache.ini /usr/local/etc/php/conf.d/opcache.ini
```

Create `docker/php/opcache.ini`:

```ini
[opcache]
opcache.enable=1
opcache.memory_consumption=256
opcache.interned_strings_buffer=16
opcache.max_accelerated_files=10000
opcache.validate_timestamps=0
opcache.save_comments=1
opcache.fast_shutdown=1
```

### 2. Use Redis for Caching

Already configured in `.env.production`:
```
CACHE_DRIVER=redis
SESSION_DRIVER=redis
QUEUE_CONNECTION=redis
```

### 3. Database Optimization

```bash
# Optimize tables
docker exec laravel-mysql mysqlcheck -u root -p${DB_PASSWORD} --optimize --all-databases

# Analyze queries
docker exec laravel-app php artisan telescope:install  # if using Telescope
```

---

## Useful Commands Reference

### Docker Commands

```bash
# View running containers
docker ps

# View all containers
docker ps -a

# Stop all containers
docker stop $(docker ps -q)

# Remove all containers
docker rm $(docker ps -a -q)

# Remove all images
docker rmi $(docker images -q)

# View container logs
docker logs <container-name>

# Execute command in container
docker exec <container-name> <command>

# Access container shell
docker exec -it <container-name> bash
```

### Docker Compose Commands

```bash
# Start services
docker-compose -f docker-compose.production.yml up -d

# Stop services
docker-compose -f docker-compose.production.yml down

# Restart services
docker-compose -f docker-compose.production.yml restart

# View logs
docker-compose -f docker-compose.production.yml logs -f

# Pull latest images
docker-compose -f docker-compose.production.yml pull

# Rebuild services
docker-compose -f docker-compose.production.yml up -d --build
```

### Laravel Artisan Commands

```bash
# Run migrations
docker exec laravel-app php artisan migrate

# Clear cache
docker exec laravel-app php artisan cache:clear

# Clear config cache
docker exec laravel-app php artisan config:clear

# Create cache
docker exec laravel-app php artisan config:cache
docker exec laravel-app php artisan route:cache
docker exec laravel-app php artisan view:cache

# Queue commands
docker exec laravel-app php artisan queue:work
docker exec laravel-app php artisan queue:restart
docker exec laravel-app php artisan queue:failed

# Run scheduler
docker exec laravel-app php artisan schedule:run
```

---

## Checklist

### Pre-Deployment Checklist

- [ ] `.env.production` configured with production values
- [ ] APP_DEBUG set to false
- [ ] Strong database passwords set
- [ ] APP_KEY generated
- [ ] Docker and Docker Compose installed on server
- [ ] SSH access to production server configured
- [ ] GitHub repository accessible
- [ ] Domain name configured (if applicable)
- [ ] Firewall rules configured
- [ ] Backup strategy implemented

### Post-Deployment Checklist

- [ ] Application accessible via browser
- [ ] Database migrations completed
- [ ] Storage link created
- [ ] Permissions set correctly
- [ ] Queue workers running
- [ ] Scheduler configured
- [ ] Logs being written correctly
- [ ] SSL certificate installed (if applicable)
- [ ] Monitoring setup
- [ ] Backup tested

### Jenkins Setup Checklist

- [ ] Jenkins installed and running
- [ ] Required plugins installed
- [ ] GitHub credentials configured
- [ ] SSH credentials configured
- [ ] Webhook configured in GitHub
- [ ] Pipeline job created
- [ ] Jenkinsfile in repository
- [ ] Test deployment successful

---

## Additional Resources

- [Laravel Documentation](https://laravel.com/docs)
- [Docker Documentation](https://docs.docker.com)
- [Jenkins Documentation](https://www.jenkins.io/doc)
- [Docker Compose Documentation](https://docs.docker.com/compose)
- [GitHub Webhooks](https://docs.github.com/en/webhooks)

---

## Support and Maintenance

For issues or questions:
1. Check application logs: `docker-compose logs -f app`
2. Check system logs: `/var/log/syslog`
3. Review this documentation
4. Check Laravel documentation
5. Review Docker logs

---

**Document Version:** 1.0
**Last Updated:** December 24, 2025
**Maintained By:** Your Team

---

## Notes

- Always test deployments in a staging environment first
- Keep backups before major changes
- Monitor application after each deployment
- Document any custom changes made to this setup
- Review and update security configurations regularly
